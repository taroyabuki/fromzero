## 3.1 入門

### 3.1.1 数値

```{r}
0x10
#> [1] 16
```

```{r}
1.23e5
#> [1] 123000
```

```{r}
2 * 3
#> [1] 6
```

```{r}
10 / 3
#> [1] 3.333333
```

```{r}
10 %/% 3 # 商
#> [1] 3

10 %% 3  # 余り
#> [1] 1
```

### 3.1.2 変数

```{r}
x <- 2
y <- 3
x * y
#> [1] 6

keras::`%<-%`(c(x, y), c(20, 30)) # まとめて名付け
x * y
#> [1] 600
```

```{r}
x <- 1 + 1
# この段階では結果は表示されない

x # 変数名を評価する．
#> [1] 2
```

### 3.1.3 文字列

```{r}
my_s <- "abcde"
```

```{r}
nchar(my_s)
#> [1] 5
```

```{r}
library(tidyverse)
str_c("This is ", "a", " pen.")
#> [1] "This is a pen."
```

```{r}
substr(x = my_s, start = 2, stop = 4)
#> [1] "bcd"
```

```{r}
tmp <- "%s is %s."
sprintf(tmp, "This", "a pen")
#> [1] "This is a pen."
```

### 3.1.4 論理値

```{r}
1 <= 2
#> [1] TRUE

1 < 0
#> [1] FALSE
```

```{r}
0.1 + 0.1 + 0.1 == 0.3
#> [1] FALSE

all.equal(0.1 + 0.1 + 0.1, 0.3)
#> [1] TRUE
```

```{r}
TRUE & FALSE # 論理積（かつ）
#> [1] FALSE

TRUE | FALSE # 論理和（または）
#> [1] TRUE

!TRUE        # 否定（でない）
#> [1] FALSE
```

#### 3.1.4.1 条件演算子

```{r}
ifelse(3 < 5, 0, 10)
#> 0
```

### 3.1.5 作業ディレクトリ

```{r}
getwd()
#> '/home/jovyan/work'
```

```{r}
setwd("..")
getwd()
#> '/home/jovyan'
```


## 3.2 関数

### 3.2.1 関数の利用

```{r}
sqrt(4)
#> [1] 2
```

```{r}
log(100, 10)
#> [1] 2
```

```{r}
log(100)         # 自然対数
# あるいは
log(100, exp(1)) # 省略しない場合

#> [1] 4.60517
```

```{r}
log10(100) # 常用対数
#> [1] 2

log2(1024) # 底が2の対数
#> [1] 10
```

#### 3.2.1.1 パイプ（Rのみ）

```{r}
library(tidyverse)
4 %>% sqrt
```

```{r}
exp(log(5))       # 通常の書き方
# あるいは
5 %>% log %>% exp # パイプを使う書き方

#> 5
```

### 3.2.2 関数の定義

```{r}
f <- function(a, b) {
  a - b
}
```

```{r}
f(3, 5)
#> [1] -2
```

#### 3.2.2.1 デフォルト引数

```{r}
f <- function(a, b = 5) {
  a - b
}

f(3) # f(3, 5)と同じこと
#> [1] -2
```

#### 3.2.2.2 無名関数

```{r}
(function(a, b) { a - b })(3, 5)
#> [1] -2
```


## 3.3 コレクション

### 3.3.1 1次元データ

```{r}
x <- c("foo", "bar", "baz")
```

```{r}
length(x)
#> [1] 3
```

```{r}
x[2]
#> [1] "bar"
```

```{r}
x[2] <- "BAR"
x # 結果の確認
#> [1] "foo" "BAR" "baz"

x[2] <- "bar" # 元に戻す．
```

```{r}
x[-2]
#> [1] "foo" "baz"
```

```{r}
c(x, "qux")
#> [1] "foo" "bar" "baz" "qux"
```

```{r}
x <- c(x, "qux")
x # 結果の確認
#> [1] "foo" "bar" "baz" "qux"
```

#### 3.3.1.1 等間隔の数値からなる1次元データ

```{r}
1:5
#> [1] 1 2 3 4 5
```

```{r}
seq(from = 0, to = 10, by = 2)
#> [1]  0  2  4  6  8 10
```

```{r}
seq(from = 0, to = 1, by = 0.5)
#> [1] 0.0 0.5 1.0
```

```{r}
seq(from = 0, to = 100, length.out = 5)
#> [1]   0  25  50  75 100
```

```{r}
rep(x = 10, times = 5)
#> [1] 10 10 10 10 10
```

#### 3.3.1.2 ファクタ（Rのみ）

```{r}
tmp <- c("グー", "パー", "グー", "パー")
x <- factor(tmp, levels = c("グー", "チョキ", "パー"))
x
#> [1] グー パー グー パー
#> Levels: グー チョキ パー
```

### 3.3.2 数値計算やデータ解析用の1次元データ

```{r}
x <- c(2, 3, 5, 7)

x + 10 # 加算
#> [1] 12 13 15 17

x * 10 # 乗算
#> [1] 20 30 50 70
```

```{r}
x <- c(2, 3)
sin(x)
#> [1] 0.9092974 0.1411200
```

```{r}
x <- c(2,  3,   5,    7)
y <- c(1, 10, 100, 1000)
x + y
#> [1]    3   13  105 1007

x * y
#> [1]    2   30  500 7000
```

```{r}
sum(x * y)
#> [1] 7532
```

```{r}
x <- c(TRUE, FALSE)
y <- c(TRUE, TRUE)
x & y
#> [1]  TRUE FALSE
```

#### 3.3.2.1 1次元データ同士の比較

```{r}
u <- c(1, 2, 3)
v <- c(1, 2, 3)
w <- c(1, 2, 4)

identical(u, v) # 全体の比較
#> [1] TRUE

identical(u, w) # 全体の比較
#> [1] FALSE

u == v          # 要素ごとの比較
#> [1] TRUE TRUE TRUE

u == w          # 要素ごとの比較
#> [1]  TRUE  TRUE FALSE
```

```{r}
sum(u == w)  # 同じ要素の数
#> [1] 2

mean(u == w) # 同じ要素の割合
#> [1] 0.6666667
```

### 3.3.3 複数種類のデータをひとまとめにする

```{r}
x <- list(1, "two")
```

```{r}
x[[2]]
#> [1] "two"
```

### 3.3.4 文字列と値のペアのコレクション

```{r}
x <- list("apple"  = "りんご",
          "orange" = "みかん")
```

```{r}
x[["grape"]] <- "ぶどう"
```

```{r}
x$apple
# あるいは
x$"apple"
# あるいは
x[["apple"]]
# あるいは
tmp <- "apple"
x[[tmp]]

#> [1] "りんご"
```

### 3.3.5 補足：コピーと参照

```{r}
x <- c("foo", "bar", "baz")
y <- x
y[2] <- "BAR" # yを更新する．
y
#> [1] "foo" "BAR" "baz"

x             # xは変わらない．
#> [1] "foo" "bar" "baz"
```


## 3.4 データフレーム

### 3.4.1 データフレームの作成

```{r}
library(tidyverse)
```

#### 3.4.1.1 データを列ごとに記述する方法

```{r}
my_df <- data.frame(
  name    = c("A", "B", "C", "D"),
  english = c( 60,  90,  70,  90),
  math    = c( 70,  80,  90, 100),
  gender  = c("f", "m", "m", "f"))
```

#### 3.4.1.2 データを見た目のとおりに記述する方法

```{r}
my_df <- tribble(
  ~name, ~english, ~math, ~gender,
  "A",         60,    70,     "f",
  "B",         90,    80,     "m",
  "C",         70,    90,     "m",
  "D",         90,   100,     "f")
```

```{r}
head(my_df)
# 結果は割愛
```

#### 3.4.1.3 データフレームのサイズ

```{r}
dim(my_df)  # 行数と列数
#> [1] 4 4

nrow(my_df) # 行数
#> [1] 4

ncol(my_df) # 列数
#> [1] 4
```

#### 3.4.1.4 組合せ

```{r}
my_df2 <- expand.grid(
  X = c(1, 2, 3),
  Y = c(10, 100))
my_df2
#>   X   Y
#> 1 1  10
#> 2 2  10
#> 3 3  10
#> 4 1 100
#> 5 2 100
#> 6 3 100
```

#### 3.4.1.5 列と行の名前

```{r}
colnames(my_df2)
#> [1] "X" "Y"
```

```{r}
colnames(my_df2) <- c("P", "Q")
my_df2
#>   P   Q
#> 1 1  10
#> 2 2  10
# 以下省略
```

```{r}
row.names(my_df)
#> [1] "1" "2" "3" "4"
```

```{r}
row.names(my_df2) <-
  c("a", "b", "c", "d", "e", "f")
my_df2
#>   P   Q
#> a 1  10
#> b 2  10
#> c 3  10
# 以下省略
```

```{r}
my_df3 <- data.frame(
  english =   c( 60,  90,  70,  90),
  math    =   c( 70,  80,  90, 100),
  gender  =   c("f", "m", "m", "f"),
  row.names = c("A", "B", "C", "D"))
my_df3
#>   english math gender
#> A      60   70      f
#> B      90   80      m
#> C      70   90      m
#> D      90  100      f
```

### 3.4.2 データの追加

#### 3.4.2.1 行の追加（データフレームの結合）

```{r}
tmp <- data.frame(
  name    = "E",
  english =  80,
  math    =  80,
  gender  = "m")
my_df2 <- rbind(my_df, tmp)
```

#### 3.4.2.2 列の追加

```{r}
my_df2 <- my_df %>%
  mutate(id = c(1, 2, 3, 4))
```

```{r}
my_df3 <- my_df               # コピー
my_df3["id"] <- c(1, 2, 3, 4) # 更新
my_df3 # 結果の確認（割愛）
```

### 3.4.3 データの取り出し

#### 3.4.3.1 観測値の取り出し

```{r}
my_df[1, 2]
#> [1] 60
```

#### 3.4.3.2 1列の取り出し（結果は1次元データ）

```{r}
x <- my_df[, 2]
# あるいは
x <- my_df$english
# あるいは
x <- my_df$"english"
# あるいは
x <- my_df[["english"]]
# あるいは
tmp <- "english"
x <- my_df[[tmp]]

x # 結果の確認（割愛）
```

#### 3.4.3.3 複数列の取り出し（結果はデータフレーム）

```{r}
x <- my_df %>% select(name, math)
```

```{r}
x <- my_df[, c(1, 3)]
```

```{r}
x <- my_df %>%
  select(-c(english, gender))
# あるいは
x <- my_df[, -c(2, 4)]
```

#### 3.4.3.4 複数行の取り出し（結果はデータフレーム）

```{r}
x <- my_df[c(1, 3), ]
```

```{r}
x <- my_df[-c(2, 4), ]
```

#### 3.4.3.5 検索

```{r}
x <- my_df[my_df$gender == "m", ]
# あるいは
x <- my_df %>% filter(gender == "m")
```

```{r}
x <- my_df[my_df$english > 80 & my_df$gender == "m", ]
# あるいは
x <- my_df %>% filter(english > 80 & gender == "m")
```

```{r}
x <- my_df[my_df$english == max(my_df$english), ]
# あるいは
x <- my_df %>% filter(english == max(my_df$english))
```

```{r}
my_df2 <- my_df # コピー
my_df2[my_df$gender == "m", ]$gender <- "M"
```

```{r}
my_df2
#>   name english math gender
#> 1    A      60   70      f
#> 2    B      90   80      M
#> 3    C      70   90      M
#> 4    D      90  100      f
```

#### 3.4.3.6 並べ替え

```{r}
x <- my_df %>% arrange(english)
```

```{r}
x <- my_df %>% arrange(-english)
```

### 3.4.4 補足：行列

#### 3.4.4.1 行列の生成

```{r}
x <- c(2, 3, 5, 7, 11, 13, 17, 19, 23,
       29, 31, 37)
A <- matrix(
  data = x,     # 1次元データ
  nrow = 3,     # 行数
  byrow = TRUE) # 行ごとの生成
A
#>      [,1] [,2] [,3] [,4]
#> [1,]    2    3    5    7
#> [2,]   11   13   17   19
#> [3,]   23   29   31   37
```

#### 3.4.4.2 データフレームと行列

```{r}
A <- my_df[, c(2, 3)] %>% as.matrix
A
#>      english math
#> [1,]      60   70
#> [2,]      90   80
#> [3,]      70   90
#> [4,]      90  100
```

```{r}
as.data.frame(A)
#>   english math
#> 1      60   70
#> 2      90   80
#> 3      70   90
#> 4      90  100
```

#### 3.4.4.3 行列の変形

```{r}
t(A)
#>         [,1] [,2] [,3] [,4]
#> english   60   90   70   90
#> math      70   80   90  100
```

#### 3.4.4.4 行列の積

```{r}
t(A) %*% A
#>         english  math
#> english   24700 26700
#> math      26700 29400
```

### 3.4.5 縦型と横型

```{r}
my_wider <- data.frame(
  day = c(25, 26, 27),
  min = c(20, 21, 15),
  max = c(24, 27, 21))
```

```{r}
my_longer <- my_wider %>%
  pivot_longer(-day)
my_longer
#> # A tibble: 6 x 3
#>     day name  value
#>   <dbl> <chr> <dbl>
#> 1    25 min      20
#> 2    25 max      24
#> 3    26 min      21
#> 4    26 max      27
#> 5    27 min      15
#> 6    27 max      21
```

```{r}
my_longer %>% pivot_wider()
#> # A tibble: 3 x 3
#>     day   min   max
#>   <dbl> <dbl> <dbl>
#> 1    25    20    24
#> 2    26    21    27
#> 3    27    15    21
```

```{r}
my_longer %>%
  ggplot(aes(x = day, y = value,
             color = name)) +
  geom_point() +
  geom_line() +
  ylab("temperature") + # y軸ラベル
  scale_x_continuous(
    breaks = my_longer$day) # x軸目盛り
```


## 3.5 1次元データの（非）類似度

### 3.5.1 ユークリッド距離

```{r}
A <- c(3,   4,  5)
B <- c(3,   4, 29)
C <- c(9, -18,  8)
AB <- B - A
AC <- C - A

sum(AB^2)^0.5
#> [1] 24

sum(AC^2)^0.5
#> [1] 23
```

### 3.5.2 マンハッタン距離

```{r}
sum(abs(AB))
#> [1] 24

sum(abs(AC))
#> [1] 31
```

### 3.5.3 コサイン類似度

```{r}
sum(A * B) /
  sum(A * A)^0.5 / sum(B * B)^0.5
#> [1] 0.8169679

sum(A * C) /
  sum(A * A)^0.5 / sum(C * C)^0.5
#> [1] -0.03265116
```

### 3.5.4 相関係数

```{r}
cor(A, B)
#> [1] 0.8824975

cor(A, C)
#> [1] -0.03266277
```

#### 3.5.4.1 データフレームを使う方法

```{r}
library(tidyverse)



my_df <- data.frame(
  x = c(3,  3,   9),
  y = c(4,  4, -18),
  z = c(5, 29,   8),
  row.names = c("A", "B", "C"))

# ユークリッド距離
my_df %>% proxy::dist("Euclidean")
#>    A  B
#> B 24
#> C 23 31


# マンハッタン距離
my_df %>% proxy::dist("Manhattan")
#>    A  B
#> B 24
#> C 31 49


# コサイン類似度
my_df %>% proxy::simil("cosine")
#>             A           B
#> B  0.81696786
#> C -0.03265116  0.29342441


# 相関係数
my_df %>% proxy::simil("correlation")
#>             A           B
#> B  0.88249750
#> C -0.03266277  0.44124132
```


## 3.6 Rのパッケージ，Pythonのモジュール

### 3.6.1 Rのパッケージ

```{r}
library(tidyverse)
```

### 3.6.2 Pythonのモジュール


## 3.7 反復処理

```{r}
library(tidyverse)
```

### 3.7.1 指定した回数→1次元データ

```{r}
f1 <- function(x) {
  tmp <- runif(x)
  mean(tmp)
}

f1(10)           # 動作確認
#> [1] 0.5776604 # 結果の例
```

```{r}
replicate(n = 3, expr = f1(10))
#> [1] 0.4672766 0.4712016 0.5579449
```

```{r}
rep(x = f1(10), times = 3)
#> [1] 0.481329 0.481329 0.481329
```

### 3.7.2 1次元データ→1次元データ

```{r}
v <- c(5, 10, 100)
v %>% map_dbl(f1)
#> [1] 0.4857329 0.5322183 0.5084124
```

```{r}
rep(x = 10, times = 3) %>% map_dbl(f1)
# 結果は割愛
```

### 3.7.3 1次元データ→データフレーム

```{r}
f2 <- function(n) {
  tmp <- runif(n)
  list(x = n,
       p = mean(tmp),
       q = sd(tmp))
}

f2(10) # 動作確認
#> $x
#> [1] 10
#>
#> $p
#> [1] 0.6840032 （平均の例）
#>
#> $q
#> [1] 0.3750788 （標準偏差の例）
```

```{r}
v <- c(5, 10, 100)
v %>% map_dfr(f2)
#>       x     p     q
#>   <dbl> <dbl> <dbl>
#> 1     5 0.560 0.320
#> 2    10 0.559 0.271
#> 3   100 0.507 0.283
```

### 3.7.4 データフレーム→データフレーム

```{r}
f3 <- function(x, y) {
  tmp <- runif(x, min = 1,
                  max = y + 1) %>%
    as.integer
  list(x = x,
       y = y,
       p = mean(tmp),
       q = sd(tmp))
}

f3(x = 10, y = 6) # 動作確認
#> $x
#> [1] 10
#>
#> $y
#> [1] 6
#>
#> $p
#> [1] 3.2 （平均の例）
#>
#> $q
#> [1] 1.316561 （標準偏差の例）
```

```{r}
my_df <- data.frame(
  x = c(5, 10, 100,  5, 10, 100),
  y = c(6,  6,   6, 12, 12,  12))

my_df %>% pmap_dfr(f3)
#>       x     y     p     q
#>   <dbl> <dbl> <dbl> <dbl>
#> 1     5     6  3     1.41
#> 2    10     6  3     1.49
#> 3   100     6  3.57  1.78
#> 4     5    12  7.6   5.22
#> 5    10    12  5.7   3.77
#> 6   100    12  6.36  3.59
```

### 3.7.5 補足：反復処理の並列化

```{r}
library(furrr)
plan(multisession) # 準備

v <- c(5, 10, 100)
v %>% future_map_dbl(f1, .options =
  furrr_options(seed = TRUE))
# 結果は割愛
```


## 3.8 その他

### 3.8.1 よく遭遇するエラーとその対処方法

### 3.8.2 変数や関数についての調査

```{r}
x <- 123
typeof(x)
#> [1] "double"
```

```{r}
?log
# あるいは
help(log)
```

### 3.8.3 RのNA，Pythonのnan

```{r}
v <- c(1, NA, 3)
v
#> [1]  1 NA  3
```

```{r}
is.na(v[2])
#> [1] TRUE

v[2] == NA # 誤り
#> [1] NA
```


